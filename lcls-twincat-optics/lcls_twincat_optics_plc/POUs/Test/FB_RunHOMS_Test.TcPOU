<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.3">
  <POU Name="FB_RunHOMS_Test" Id="{c81c4f62-34f7-4ff5-b928-2b2a5091b392}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RunHOMS_Test EXTENDS TcUnit.FB_TestSuite
VAR
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CoupledAfterStartup();
//GantryInterlockStopsMotion();
DecoupledGantryDecrease();]]></ST>
    </Implementation>
    <Method Name="CoupledAfterStartup" Id="{2e7b3eec-c796-4614-b0fd-9bd3d4f01b04}">
      <Declaration><![CDATA[METHOD CoupledAfterStartup
VAR
	// Test Struct
	TestHOMS : DUT_HOMS;

	bExpectedCoupleStatus : BOOL := TRUE;
	bActualCoupleStatus : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Testing automatic coupling of gantried Y and X axes
// Currently takes 1 additinal cycle for coupling to take effect after the command is sent
// Therefore need to wait one cycle before checking couple status
TEST('CoupledAfterStartup');

TestHOMS.fbRunHOMS(stYup:=GVL_CoupledAfterStartup.M1,
		  		   stYdwn:=GVL_CoupledAfterStartup.M2,
		           stXup:=GVL_CoupledAfterStartup.M3,
		           stXdwn:=GVL_CoupledAfterStartup.M4,
		           stPitch:=GVL_CoupledAfterStartup.M5,
		           nYupEncRef:=0,
		           nYdwnEncRef:=0,
		           nXupEncRef:=0,
		           nXdwnEncRef:=0,
		           bExecuteCoupleY:=TestHOMS.bExecuteCoupleY,
                   bExecuteCoupleX:=TestHOMS.bExecuteCoupleX,
		           bExecuteDecoupleY:=TestHOMS.bExecuteDecoupleY,
                   bExecuteDecoupleX:=TestHOMS.bExecuteDecoupleX,
                   bGantryAlreadyCoupledY=>TestHOMS.bGantryAlreadyCoupledY,
                   bGantryAlreadyCoupledX=>TestHOMS.bGantryAlreadyCoupledX,
                   nCurrGantryY=>TestHOMS.nCurrGantryY,
                   nCurrGantryX=>TestHOMS.nCurrGantryX);

bActualCoupleStatus := TestHOMS.bGantryAlreadyCoupledY AND TestHOMS.bGantryAlreadyCoupledX;
IF NOT GVL_CoupledAfterStartup.bFirstCycle THEN
	AssertEquals(Expected := bExpectedCoupleStatus,
	         	 Actual := bActualCoupleStatus,
			 	 Message := 'Either the Y or X gantry axes did not couple after startup');
	TEST_FINISHED();
END_IF;
GVL_CoupledAfterStartup.bFirstCycle := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="DecoupledGantryDecrease" Id="{cb07ba3d-99e7-4ccb-a1f7-052bfaed75a3}">
      <Declaration><![CDATA[METHOD DecoupledGantryDecrease
VAR
	nCurrGantry : LINT;
//	fbAutoCouple : FB_GantryAutoCoupling;

	fbMotionStage_master : FB_MotionStage;
	fbMotionStage_slave : FB_MotionStage;
	
	bExpectedResult : BOOL := TRUE;
	bActualResult : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Testing motion stop for decoupled gantried axes when gantry > gantry tol
// and that motion is allowed in directions that reduce the gantry
TEST('DecoupledGantryDecrease');

GVL_DecoupledGantryDecrease.nCycleCount := GVL_DecoupledGantryDecrease.nCycleCount + 1;

// EnableBits
GVL_DecoupledGantryDecrease.M1.bLimitForwardEnable := True; // Enable Limits
GVL_DecoupledGantryDecrease.M1.bLimitBackwardEnable := True;
GVL_DecoupledGantryDecrease.M1.bPowerSelf := True; // Enable Power
GVL_DecoupledGantryDecrease.M1.bHardwareEnable := True; // Enable STO
GVL_DecoupledGantryDecrease.M1.nCommand := 3; // Enable Motion Through PLC
GVL_DecoupledGantryDecrease.M1.nEnableMode := ENUM_StageEnableMode.ALWAYS;

GVL_DecoupledGantryDecrease.M2.bLimitForwardEnable := True; // Enable Limits
GVL_DecoupledGantryDecrease.M2.bLimitBackwardEnable := True;
GVL_DecoupledGantryDecrease.M2.bPowerSelf := True; // Enable Power
GVL_DecoupledGantryDecrease.M2.bHardwareEnable := True; // Enable STO
GVL_DecoupledGantryDecrease.M2.nCommand := 3; // Enable Motion Through PLC
GVL_DecoupledGantryDecrease.M2.nEnableMode := ENUM_StageEnableMode.ALWAYS;

// Enc Ref Vals
GVL_DecoupledGantryDecrease.stMasterEnc.Ref := 0;
GVL_DecoupledGantryDecrease.stSlaveEnc.Ref := 0;

// Fake Encoder Position Readback
GVL_DecoupledGantryDecrease.stMasterEnc.Count := 10000000 + LREAL_TO_ULINT(GVL_DecoupledGantryDecrease.M1.stAxisStatus.fActPosition * EXPT(10, 5)); // Position positive => counts up
GVL_DecoupledGantryDecrease.stSlaveEnc.Count := 10000000 + LREAL_TO_ULINT(GVL_DecoupledGantryDecrease.M2.stAxisStatus.fActPosition * EXPT(10, 5)); // Position negative => counts down

nCurrGantry := ((ULINT_TO_LINT(GVL_DecoupledGantryDecrease.stMasterEnc.Count) - ULINT_TO_LINT(GVL_DecoupledGantryDecrease.stMasterEnc.Ref)) - (ULINT_TO_LINT(GVL_DecoupledGantryDecrease.stSlaveEnc.Count) - ULINT_TO_LINT(GVL_DecoupledGantryDecrease.stSlaveEnc.Ref)));

IF GVL_DecoupledGantryDecrease.nCycleCount = 5 THEN
	GVL_DecoupledGantryDecrease.bExecuteDecoupleIn := TRUE;
	GVL_DecoupledGantryDecrease.M1.fPosition := 10.0;
	GVL_DecoupledGantryDecrease.M1.fVelocity := 0.2;

	GVL_DecoupledGantryDecrease.M2.fPosition := -10.0;
	GVL_DecoupledGantryDecrease.M2.fVelocity := 0.2;
END_IF;
	
IF GVL_DecoupledGantryDecrease.nCycleCount = 10 THEN
	GVL_DecoupledGantryDecrease.M1.bExecute := TRUE;
	GVL_DecoupledGantryDecrease.M2.bExecute := TRUE;
END_IF;

GVL_DecoupledGantryDecrease.fbAutoCouple(
	nGantryTol:=GVL_Constants.nGANTRY_TOLERANCE_NM_DEFAULT,
    Master:=GVL_DecoupledGantryDecrease.M1,
    MasterEnc:=GVL_DecoupledGantryDecrease.stMasterEnc,
    Slave:=GVL_DecoupledGantryDecrease.M2,
	SlaveEnc:=GVL_DecoupledGantryDecrease.stSlaveEnc,
    bExecuteCouple:=GVL_DecoupledGantryDecrease.bExecuteCoupleIn,
    bExecuteDecouple:=GVL_DecoupledGantryDecrease.bExecuteDecoupleIn,
	bGantryAlreadyCoupled=>GVL_DecoupledGantryDecrease.bGantryAlreadyCoupledOut);

fbMotionStage_master(stMotionStage:=GVL_DecoupledGantryDecrease.M1);
fbMotionStage_slave(stMotionStage:=GVL_DecoupledGantryDecrease.M2);

IF nCurrGantry > GVL_Constants.nGANTRY_TOLERANCE_NM_DEFAULT THEN
	bActualResult := (NOT GVL_DecoupledGantryDecrease.M1.bAllForwardEnable) AND (GVL_DecoupledGantryDecrease.M1.bAllBackwardEnable) AND (GVL_DecoupledGantryDecrease.M2.bAllForwardEnable) AND (NOT GVL_DecoupledGantryDecrease.M2.bAllBackwardEnable);
	AssertEquals(Expected := bExpectedResult,
		         Actual := bActualResult,
				 Message := 'Decoupled axes continued motion with gantry larger than the tolerance and/or motion not allowed in direction to reduce gantry');
	TEST_FINISHED();
END_IF;

IF GVL_DecoupledGantryDecrease.nCycleCount = 1000000000 THEN
	GVL_DecoupledGantryDecrease.nCycleCount := 0;
END_IF;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GantryInterlockStopsMotion" Id="{3d3b7799-5ae8-4960-a155-ad97b264959c}">
      <Declaration><![CDATA[METHOD GantryInterlockStopsMotion
VAR
	fEncSepFactor : REAL := 1.5;
	bExecuteCouple : BOOL;
	bExecuteDecouple : BOOL;
	bGantryAlreadyCoupled : BOOL;
	fbAutoCouple : FB_GantryAutoCoupling;
	fbMotionStage_master : FB_MotionStage;
	fbMotionStage_slave : FB_MotionStage;
	nCurrGantry : LINT;

	bExpectedEnableStatus : BOOL := FALSE;
	bActualEnableStatus : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Testing automatic motion stop when gantry difference of master and slave axes exceeds a tolerance
// Fake motor separation using fEncSepFactor which scales the readback of the master axis relative to the slave, causing the gantry to grow
// Ensuring Forward/Backward enables are FALSE for master and slave axes when gantry exceeds the tolerance
TEST('GantryInterlockStopsMotion');
// Cannot use FB_RunHOMS since enc counts are not inputs
// Need to test this behavior at next level down, i.e interfacing with fbAutoCouple

// Enable Bits
GVL_GantryInterlockStopsMotion.M1.bLimitForwardEnable := True; // Enable Limits
GVL_GantryInterlockStopsMotion.M1.bLimitBackwardEnable := True;
GVL_GantryInterlockStopsMotion.M1.bPowerSelf := True; // Enable Power
GVL_GantryInterlockStopsMotion.M1.bHardwareEnable := True; // Enable STO
GVL_GantryInterlockStopsMotion.M1.nCommand := 3; // Enable Motion Through PLC
GVL_GantryInterlockStopsMotion.M1.nEnableMode := ENUM_StageEnableMode.ALWAYS;

GVL_GantryInterlockStopsMotion.M2.bLimitForwardEnable := True; // Enable Limits
GVL_GantryInterlockStopsMotion.M2.bLimitBackwardEnable := True;
GVL_GantryInterlockStopsMotion.M2.bPowerSelf := True; // Enable Power
GVL_GantryInterlockStopsMotion.M2.bHardwareEnable := True; // Enable STO
GVL_GantryInterlockStopsMotion.M2.nCommand := 3; // Enable Motion Through PLC
GVL_GantryInterlockStopsMotion.M2.nEnableMode := ENUM_StageEnableMode.ALWAYS;

// Enc Ref Vals
GVL_GantryInterlockStopsMotion.stMasterEnc.Ref := 0;
GVL_GantryInterlockStopsMotion.stSlaveEnc.Ref := 0;

// Fake Encoder Position Readback
GVL_GantryInterlockStopsMotion.stMasterEnc.Count := LREAL_TO_ULINT(GVL_GantryInterlockStopsMotion.M1.stAxisStatus.fActPosition * fEncSepFactor * EXPT(10, 6));
GVL_GantryInterlockStopsMotion.stSlaveEnc.Count := LREAL_TO_ULINT(GVL_GantryInterlockStopsMotion.M2.stAxisStatus.fActPosition * EXPT(10, 6));

nCurrGantry := ((ULINT_TO_LINT(GVL_GantryInterlockStopsMotion.stMasterEnc.Count) - ULINT_TO_LINT(GVL_GantryInterlockStopsMotion.stMasterEnc.Ref)) - (ULINT_TO_LINT(GVL_GantryInterlockStopsMotion.stSlaveEnc.Count) - ULINT_TO_LINT(GVL_GantryInterlockStopsMotion.stSlaveEnc.Ref)));

fbAutoCouple(nGantryTol:=GVL_Constants.nGANTRY_TOLERANCE_NM_DEFAULT,
             Master:=GVL_GantryInterlockStopsMotion.M1,
             MasterEnc:=GVL_GantryInterlockStopsMotion.stMasterEnc,
             Slave:=GVL_GantryInterlockStopsMotion.M2,
	         SlaveEnc:=GVL_GantryInterlockStopsMotion.stSlaveEnc,
             bExecuteCouple:=bExecuteCouple,
             bExecuteDecouple:=bExecuteDecouple,
			 bGantryAlreadyCoupled=>bGantryAlreadyCoupled);

GVL_GantryInterlockStopsMotion.M1.fPosition := 5.0;
GVL_GantryInterlockStopsMotion.M1.fVelocity := 1.0;
GVL_GantryInterlockStopsMotion.M1.bExecute := TRUE;
	
fbMotionStage_master(stMotionStage:=GVL_GantryInterlockStopsMotion.M1);
fbMotionStage_slave(stMotionStage:=GVL_GantryInterlockStopsMotion.M2);

IF nCurrGantry > GVL_Constants.nGANTRY_TOLERANCE_NM_DEFAULT THEN
	bActualEnableStatus := (GVL_GantryInterlockStopsMotion.M1.bAllForwardEnable OR GVL_GantryInterlockStopsMotion.M1.bAllBackwardEnable OR GVL_GantryInterlockStopsMotion.M2.bAllForwardEnable OR GVL_GantryInterlockStopsMotion.M2.bAllBackwardEnable);
	AssertEquals(Expected := bExpectedEnableStatus,
		         Actual := bActualEnableStatus,
				 Message := 'Either master or slave continued motion after exceeding gantry tolerance');
	TEST_FINISHED();
END_IF;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>